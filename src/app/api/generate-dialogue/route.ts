import { NextRequest, NextResponse } from 'next/server'
import { v4 as uuidv4 } from 'uuid'
import { redisService } from '@/utils/redis'
import { elevenLabs, type Character } from '@/utils/elevenlabs'
import { s3Service } from '@/utils/s3'
import { mediaConvert } from '@/utils/mediaconvert'

export interface DialogueRequest {
  dialogue: Array<{
    character: Character;
    text: string;
  }>;
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json() as DialogueRequest
    const conversationId = uuidv4()
    
    // Check if this conversation is already being processed
    const processingKey = `processing:${conversationId}`
    const isProcessing = await redisService.getConversation(conversationId)
    if (isProcessing) {
      return NextResponse.json(
        { error: 'This conversation is already being processed' },
        { status: 409 }
      )
    }

    // Generate audio for all dialogue segments
    const audioSegments = await elevenLabs.generateConversation(body.dialogue)

    // Upload all audio segments to S3
    const uploads = await s3Service.uploadMultipleAudio(audioSegments, conversationId)

    // Get signed URLs for all uploaded audio segments
    const audioUrls = await Promise.all(
      uploads.map(async ({ character, audioKey }) => ({
        character,
        url: await s3Service.getSignedUrl(audioKey),
        directUrl: `https://${process.env.AWS_BUCKET_NAME}.s3.${process.env.AWS_REGION || 'us-east-1'}.amazonaws.com/${audioKey}`
      }))
    )

    // Create MediaConvert job to assemble podcast
    const segments = audioSegments.map((segment, index) => ({
      url: audioUrls[index].directUrl,
      startTime: segment.startTime,
      endTime: segment.endTime,
      speaker: segment.character.name
    }))

    // Cache conversation data in Redis
    await redisService.cacheConversation({
      conversationId,
      audioSegments: audioSegments.map((segment, index) => ({
        character: segment.character.name,
        audioKey: uploads[index].audioKey,
        timestamps: segment.timestamps,
        startTime: segment.startTime,
        endTime: segment.endTime
      })),
      transcript: {
        srt: '', // Will be generated by MediaConvert
        vtt: '', // Will be generated by MediaConvert
        json: {
          segments: segments.map(s => ({
            speaker: s.speaker,
            startTime: s.startTime,
            endTime: s.endTime
          }))
        }
      },
      metadata: {
        totalDuration: Math.max(...segments.map(s => s.endTime)),
        speakers: [...new Set(segments.map(s => s.speaker))],
        turnCount: segments.length,
        createdAt: Date.now()
      }
    })

    // Create MediaConvert job
    const jobId = await mediaConvert.createPodcastJob({
      segments,
      outputBucket: process.env.AWS_BUCKET_NAME!,
      outputKey: `conversations/${conversationId}/podcast`
    })

    return NextResponse.json({
      conversationId,
      audioUrls,
      jobId
    })
  } catch (error) {
    console.error('Error generating dialogue:', error)
    return NextResponse.json(
      { error: 'Failed to generate dialogue' },
      { status: 500 }
    )
  }
}

// Endpoint to get status/results of a conversation
export async function GET(req: NextRequest) {
  const url = new URL(req.url)
  const conversationId = url.searchParams.get('conversationId')

  if (!conversationId) {
    return NextResponse.json(
      { error: 'Conversation ID is required' },
      { status: 400 }
    )
  }

  try {
    const conversation = await redisService.getConversation(conversationId)
    if (!conversation) {
      return NextResponse.json(
        { error: 'Conversation not found' },
        { status: 404 }
      )
    }

    // Generate fresh signed URLs for audio files
    const audioUrls = await Promise.all(
      conversation.audioSegments.map(async ({ character, audioKey }) => ({
        character,
        url: await s3Service.getSignedUrl(audioKey),
        directUrl: `https://${process.env.AWS_BUCKET_NAME}.s3.${process.env.AWS_REGION || 'us-east-1'}.amazonaws.com/${audioKey}`
      }))
    )

    return NextResponse.json({
      audioUrls,
      metadata: conversation.metadata,
      transcript: conversation.transcript
    })
  } catch (error) {
    console.error('Error fetching conversation:', error)
    return NextResponse.json(
      { error: 'Failed to fetch conversation' },
      { status: 500 }
    )
  }
}
